const { pool } = require("../config/db");
const bcrypt = require("bcryptjs");

const User = {
  // Find user by email
  findByEmail: async (email) => {
    const [rows] = await pool.execute(
      `SELECT u.*, LOWER(r.role_name) as role 
       FROM users u 
       JOIN roles r ON u.role_id = r.role_id 
       WHERE u.email = ?`,
      [email]
    );
    return rows[0];
  },

  // Find user by ID
  findById: async (id) => {
    const [rows] = await pool.execute(
      `SELECT u.id, u.email, u.full_name, u.role_id, u.phone, u.specialization, u.is_active, u.created_at, LOWER(r.role_name) as role
       FROM users u
       JOIN roles r ON u.role_id = r.role_id
       WHERE u.id = ?`,
      [id]
    );
    return rows[0];
  },

  // Create new user
  create: async (userData) => {
    const { email, password, full_name, role_id, phone, specialization } =
      userData;
    const password_hash = await bcrypt.hash(password, 10);

    const [result] = await pool.execute(
      "INSERT INTO users (email, password_hash, full_name, role_id, phone, specialization) VALUES (?, ?, ?, ?, ?, ?)",
      [email, password_hash, full_name, role_id, phone, specialization]
    );

    // Return the created user
    // Note: Since we use UUIDs (default) or auto-increment, we might need to fetch it back if UUID is generated by DB.
    // For this schema, ID is UUID() default. reliable way is to fetch by email or use UUID passed from app.
    // However, schema says DEFAULT (UUID()), so we can't get ID easily from INSERT result in MySQL 5.7/8.0 without returning.
    // We'll fetch by email for now as it makes it simpler.
    return User.findByEmail(email);
  },

  // Verify password
  verifyPassword: async (user, password) => {
    return await bcrypt.compare(password, user.password_hash);
  },
};

module.exports = User;
